<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue常见面试题 | 水星记</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.4.0">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.14dd4b56.css" as="style"><link rel="preload" href="/assets/js/app.50e95c75.js" as="script"><link rel="preload" href="/assets/js/3.d50137cb.js" as="script"><link rel="preload" href="/assets/js/1.31fe4405.js" as="script"><link rel="preload" href="/assets/js/23.fa856cca.js" as="script"><link rel="preload" href="/assets/js/9.ca18e909.js" as="script"><link rel="prefetch" href="/assets/js/10.02f85c94.js"><link rel="prefetch" href="/assets/js/11.af1f87dc.js"><link rel="prefetch" href="/assets/js/12.237fe453.js"><link rel="prefetch" href="/assets/js/13.73dc1929.js"><link rel="prefetch" href="/assets/js/14.6a473dcf.js"><link rel="prefetch" href="/assets/js/15.2b3d8f88.js"><link rel="prefetch" href="/assets/js/16.426ed51c.js"><link rel="prefetch" href="/assets/js/17.501df5cb.js"><link rel="prefetch" href="/assets/js/18.c4a577c6.js"><link rel="prefetch" href="/assets/js/19.f7e8443d.js"><link rel="prefetch" href="/assets/js/20.1c765490.js"><link rel="prefetch" href="/assets/js/21.1178e721.js"><link rel="prefetch" href="/assets/js/22.8664a68a.js"><link rel="prefetch" href="/assets/js/24.81229bd1.js"><link rel="prefetch" href="/assets/js/25.bfcfdb91.js"><link rel="prefetch" href="/assets/js/26.b34c0d39.js"><link rel="prefetch" href="/assets/js/4.91ddb18e.js"><link rel="prefetch" href="/assets/js/5.0d10d3f3.js"><link rel="prefetch" href="/assets/js/6.986dcd48.js"><link rel="prefetch" href="/assets/js/7.9f014a41.js"><link rel="prefetch" href="/assets/js/8.f11cef01.js">
    <link rel="stylesheet" href="/assets/css/0.styles.14dd4b56.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-146b4d24><div data-v-146b4d24><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-146b4d24 data-v-146b4d24><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-146b4d24 data-v-146b4d24><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>水星记</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>陈庆宇</span>
            
          <!---->
          2020
        </a></span></div></div> <div class="hide" data-v-146b4d24><header class="navbar" data-v-146b4d24><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">水星记</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont undefined"></i>
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link"><i class="iconfont undefined"></i>
  Guide
</a></div><div class="nav-item"><a href="/javascript/" class="nav-link"><i class="iconfont undefined"></i>
  JavaScript
</a></div><div class="nav-item"><a href="/vue/" class="nav-link router-link-active"><i class="iconfont undefined"></i>
  Vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link"><i class="iconfont undefined"></i>
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      更多
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://v1.vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  VuePress官网
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-146b4d24></div> <aside class="sidebar" data-v-146b4d24><div class="personal-info-wrapper" data-v-b038cec6><img src="https://tvax1.sinaimg.cn/crop.0.0.1080.1080.180/0072bjDtly8gdr2rmhov6j30u00u0418.jpg?KID=imgbed,tva&amp;Expires=1586949398&amp;ssig=rjthBBRT6R" alt="author-avatar" class="personal-img" data-v-b038cec6> <h3 class="name" data-v-b038cec6>
    陈庆宇
  </h3> <div class="num" data-v-b038cec6><div data-v-b038cec6><h3 data-v-b038cec6>4</h3> <h6 data-v-b038cec6>Article</h6></div> <div data-v-b038cec6><h3 data-v-b038cec6>0</h3> <h6 data-v-b038cec6>Tag</h6></div></div> <hr data-v-b038cec6></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont undefined"></i>
  Home
</a></div><div class="nav-item"><a href="/guide/" class="nav-link"><i class="iconfont undefined"></i>
  Guide
</a></div><div class="nav-item"><a href="/javascript/" class="nav-link"><i class="iconfont undefined"></i>
  JavaScript
</a></div><div class="nav-item"><a href="/vue/" class="nav-link router-link-active"><i class="iconfont undefined"></i>
  Vue
</a></div><div class="nav-item"><a href="/react/" class="nav-link"><i class="iconfont undefined"></i>
  React
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      更多
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://v1.vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont undefined"></i>
  VuePress官网
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue/" class="sidebar-link">首页</a></li><li><a href="/vue/vue_ questions.html" class="active sidebar-link">Vue常见面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#一、说说你对-spa-单页面的理解，它的优缺点分别是什么？" class="sidebar-link">一、说说你对 SPA 单页面的理解，它的优缺点分别是什么？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#二、v-show与v-if有什么区别？" class="sidebar-link">二、v-show与v-if有什么区别？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#三、class和style如何动态绑定？" class="sidebar-link">三、Class和Style如何动态绑定？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#四、怎样理解vue的单项数据流？" class="sidebar-link">四、怎样理解Vue的单项数据流？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#五、computed和watch的区别和运用场景？" class="sidebar-link">五、computed和watch的区别和运用场景？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#六、直接给一个数组赋值，vue能检测到变化吗？" class="sidebar-link">六、直接给一个数组赋值，Vue能检测到变化吗？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#七、谈谈你对vue生命周期的理解？" class="sidebar-link">七、谈谈你对Vue生命周期的理解？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#八、vue的父组件和子组件生命周期钩子函数执行顺序？" class="sidebar-link">八、Vue的父组件和子组件生命周期钩子函数执行顺序？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#九、在哪个生命周期内调用异步请求？" class="sidebar-link">九、在哪个生命周期内调用异步请求？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#十、在什么阶段才能访问操作dom？" class="sidebar-link">十、在什么阶段才能访问操作DOM？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#十一、父组件可以监听到子组件的生命周期吗？" class="sidebar-link">十一、父组件可以监听到子组件的生命周期吗？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#十二、谈谈你对keep-alive-的了解？" class="sidebar-link">十二、谈谈你对keep-alive 的了解？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#十三、组件中data为什么是一个函数？" class="sidebar-link">十三、组件中data为什么是一个函数？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#十四、v-model-的原理？" class="sidebar-link">十四、v-model 的原理？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#十五、vue组件间的通信有哪几种方式？" class="sidebar-link">十五、Vue组件间的通信有哪几种方式？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#十六、vuex是什么？怎么使用？哪种功能场景使用它？" class="sidebar-link">十六、vuex是什么？怎么使用？哪种功能场景使用它？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#十七、导航钩子有哪些？它们有哪些参数？" class="sidebar-link">十七、导航钩子有哪些？它们有哪些参数？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#十八、异步dom更新" class="sidebar-link">十八、异步DOM更新</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#十九、vue-loader解释一下" class="sidebar-link">十九、vue-loader解释一下</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#二十、用过插槽吗？用的是具名插槽还是匿名插槽？" class="sidebar-link">二十、用过插槽吗？用的是具名插槽还是匿名插槽？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#二十一、说说你对虚拟dom-的理解" class="sidebar-link">二十一、说说你对虚拟DOM 的理解</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#二十二、pre-和cloak-指令" class="sidebar-link">二十二、pre 和cloak 指令</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#二十三、什么是-mixin？" class="sidebar-link">二十三、什么是 mixin？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#二十四、key的作用" class="sidebar-link">二十四、key的作用</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#二十五、怎么定义-vue-router-的动态路由-怎么获取传过来的值？" class="sidebar-link">二十五、怎么定义 vue-router 的动态路由? 怎么获取传过来的值？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#二十六、路由懒加载" class="sidebar-link">二十六、路由懒加载</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#二十七、为何vue中采用异步更新？" class="sidebar-link">二十七、为何Vue中采用异步更新？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#二十八、vue中是如何检测数组变化？" class="sidebar-link">二十八、Vue中是如何检测数组变化？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#二十九、nexttick实现原理？" class="sidebar-link">二十九、nextTick实现原理？</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#三十、vue中computed特点" class="sidebar-link">三十、Vue中computed特点</a></li><li class="sidebar-sub-header"><a href="/vue/vue_ questions.html#三十一、解释一下编译过程" class="sidebar-link">三十一、解释一下编译过程</a></li></ul></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-146b4d24><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Vue常见面试题</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>陈庆宇</span>
            
          <!---->
          2020
        </a></span></div></div> <div data-v-146b4d24><main class="page"><div class="page-title" style="display:none;"><h1>Vue常见面试题</h1> <hr> <div data-v-484a899e><i class="iconfont reco-account" data-v-484a899e><span data-v-484a899e>陈庆宇</span></i> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default" style="display:none;"><h2 id="一、说说你对-spa-单页面的理解，它的优缺点分别是什么？"><a href="#一、说说你对-spa-单页面的理解，它的优缺点分别是什么？" class="header-anchor">#</a> 一、说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h2> <p>SPA仅在Web页面初始化加载响应的HTML、JS和CSS。一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现HTML内容的变换，避免页面的重新加载。</p> <p>优点：</p> <ol><li>用户体验好、快，内容改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染。</li> <li>对服务器压力小。</li> <li>前后端职责分离，架构清晰。</li></ol> <p>缺点：</p> <ol><li>初次加载耗时多：需要在加载页面时将JS、CSS统一加载，部分页面按需加载。</li> <li>前进后退路由管理</li> <li>SEO难度大</li></ol> <h2 id="二、v-show与v-if有什么区别？"><a href="#二、v-show与v-if有什么区别？" class="header-anchor">#</a> 二、v-show与v-if有什么区别？</h2> <p>v-show 不管条件是什么，内容总是会被渲染，只是简单基于CSS的”display“属性的进行切换。
v-if  是真正的条件渲染，在组件的创建建和销毁之间切换。
如果不需要频繁切换条件用v-if，需要频繁切换条件的场景使用v-show。</p> <h2 id="三、class和style如何动态绑定？"><a href="#三、class和style如何动态绑定？" class="header-anchor">#</a> 三、Class和Style如何动态绑定？</h2> <p>Class可以通过对象语法和数组语法进行动态绑定：</p> <ul><li>对象语法：<div class="language-js extra-class"><pre class="language-js"><code> <span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token operator">:</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;{ active: isActive, 'text-danger': hasError }&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
 data<span class="token operator">:</span> <span class="token punctuation">{</span> isActive<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> hasError<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span>
</code></pre></div></li> <li>数组语法：<div class="language-js extra-class"><pre class="language-js"><code> <span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token operator">:</span><span class="token keyword">class</span><span class="token operator">=</span><span class="token string">&quot;[isActive ? activeClass : '', errorClass]&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span> 
 data<span class="token operator">:</span> <span class="token punctuation">{</span> activeClass<span class="token operator">:</span> <span class="token string">'active'</span><span class="token punctuation">,</span> errorClass<span class="token operator">:</span> 'text<span class="token operator">-</span>danger’ <span class="token punctuation">}</span>
</code></pre></div></li></ul> <p>Style 也可以通过对象语法和数组语法进行动态绑定：</p> <ul><li>对象语法：<div class="language-js extra-class"><pre class="language-js"><code> <span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token operator">:</span>style<span class="token operator">=</span><span class="token string">&quot;{ color: activeColor, fontSize: fontSize + 'px' }&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span> 
 data<span class="token operator">:</span> <span class="token punctuation">{</span> activeColor<span class="token operator">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span> fontSize<span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">}</span>
</code></pre></div></li> <li>数组语法：<div class="language-js extra-class"><pre class="language-js"><code>  <span class="token operator">&lt;</span>div v<span class="token operator">-</span>bind<span class="token operator">:</span>style<span class="token operator">=</span><span class="token string">&quot;[styleColor, styleSize]&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span> 
  data<span class="token operator">:</span> <span class="token punctuation">{</span> styleColor<span class="token operator">:</span> <span class="token punctuation">{</span> color<span class="token operator">:</span> <span class="token string">'red'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> styleSize<span class="token operator">:</span><span class="token punctuation">{</span> fontSize<span class="token operator">:</span><span class="token string">'23px'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="四、怎样理解vue的单项数据流？"><a href="#四、怎样理解vue的单项数据流？" class="header-anchor">#</a> 四、怎样理解Vue的单项数据流？</h2> <p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。
额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p> <h2 id="五、computed和watch的区别和运用场景？"><a href="#五、computed和watch的区别和运用场景？" class="header-anchor">#</a> 五、computed和watch的区别和运用场景？</h2> <p>computed：是计算属性，依赖它的属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值；
watch：更多的是观察作用，类似于某些数据监听回调，每当监听的数据变化时都会执行回调进行后操作（watch只能监听值类型，如果需要监听引用数据类型，需要设置deep属性为true，而且不能获取oldValue值）</p> <h2 id="六、直接给一个数组赋值，vue能检测到变化吗？"><a href="#六、直接给一个数组赋值，vue能检测到变化吗？" class="header-anchor">#</a> 六、直接给一个数组赋值，Vue能检测到变化吗？</h2> <p>vue实例创建之后添加新的属性到实例上，它不会触发视图更新
当生成vue实例后，当再次给数据赋值时，有时候并不会自动更新到视图上去；
子组件的props数据不能与父组件传递的值实时保持一致。</p> <blockquote><p>可以使用$set方法</p></blockquote> <h2 id="七、谈谈你对vue生命周期的理解？"><a href="#七、谈谈你对vue生命周期的理解？" class="header-anchor">#</a> 七、谈谈你对Vue生命周期的理解？</h2> <p>Vue实例有一个完整的生命周期，是从开始创建、初始化数据、编译模板、挂载Dom 渲染 更新 渲染 卸载等一系列过程，我们称是Vue的生命周期。</p> <table><thead><tr><th>生命周期</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td style="text-align:center;">组件实例被创建之初，组件的属性生效之前</td></tr> <tr><td>created</td> <td style="text-align:center;">组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr> <tr><td>beforeMount</td> <td style="text-align:center;">在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr> <tr><td>mounted</td> <td style="text-align:center;">el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr> <tr><td>beforeUpdate</td> <td style="text-align:center;">组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr> <tr><td>update</td> <td style="text-align:center;">组件数据更新之后</td></tr> <tr><td>beforeDestory</td> <td style="text-align:center;">组件销毁前调用</td></tr> <tr><td>destoryed</td> <td style="text-align:center;">组件销毁后调用</td></tr> <tr><td>activited</td> <td style="text-align:center;">keep-alive 专属，组件被激活时调用</td></tr> <tr><td>deactivated</td> <td style="text-align:center;">keep-alive 专属，组件被销毁时调用</td></tr></tbody></table> <h2 id="八、vue的父组件和子组件生命周期钩子函数执行顺序？"><a href="#八、vue的父组件和子组件生命周期钩子函数执行顺序？" class="header-anchor">#</a> 八、Vue的父组件和子组件生命周期钩子函数执行顺序？</h2> <p>Vue的父组件和子组件生命周期钩子函数执行顺序可以归类以下4部分：</p> <ul><li><p>加载渲染过程
父beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子mounted -&gt; 父 mounted</p></li> <li><p>子组件更新过程
父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p></li> <li><p>父组件更新过程
父 beforeUpdate -&gt; 父 updated</p></li> <li><p>销毁过程
父 beforeDestory -&gt; 子 beforeDestory -&gt; 子 destroyed -&gt; 父 destoryed</p></li></ul> <h2 id="九、在哪个生命周期内调用异步请求？"><a href="#九、在哪个生命周期内调用异步请求？" class="header-anchor">#</a> 九、在哪个生命周期内调用异步请求？</h2> <p>可以在钩子函数created、beforeMount、mounted中调用，因为在这三个钩子函数中，data已经创建，可以将服务端返回来的数据进行赋值。但更推荐在created中调用异步请求。 有以下优点：
能更快获取到服务端数据，减少页面加载时间
ssr不支持beforeMount、mounted钩子函数，所以放在created中有助于一致性；</p> <h2 id="十、在什么阶段才能访问操作dom？"><a href="#十、在什么阶段才能访问操作dom？" class="header-anchor">#</a> 十、在什么阶段才能访问操作DOM？</h2> <p>在钩子函数mounted被调用前，Vue已经将模板挂载到页面上了，所以在mounted中可以访问操作DOM。</p> <h2 id="十一、父组件可以监听到子组件的生命周期吗？"><a href="#十一、父组件可以监听到子组件的生命周期吗？" class="header-anchor">#</a> 十一、父组件可以监听到子组件的生命周期吗？</h2> <p>比如有父组件Parent和子组件Child，如果父组件监听到子组件挂载mounted就做些逻辑处理，可以通过以下写法实现:</p> <div class="language-js extra-class"><pre class="language-js"><code>Parent<span class="token punctuation">.</span>vue
<span class="token operator">&lt;</span>Child @mounted<span class="token operator">=</span>“doSomething” <span class="token operator">/</span><span class="token operator">&gt;</span>

Child<span class="token punctuation">.</span>vue
<span class="token function">mounted</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span>“mounted”<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上需要手动通过$emit触发父组件的事件，更简单的方式可以在父组件引用子组件时通过@hook来监听，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code>Parent<span class="token punctuation">.</span>vue
<span class="token operator">&lt;</span>Child @hook<span class="token operator">:</span>mounted<span class="token operator">=</span>“doSomething”<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Child<span class="token operator">&gt;</span>

<span class="token function">doSomething</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>‘父组件监听到mounted函数’<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Child<span class="token punctuation">.</span>vue
<span class="token function">mounted</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>‘子组件触发mounted函数’<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>@hook也可以监听其他生命周期事件。</p> <h2 id="十二、谈谈你对keep-alive-的了解？"><a href="#十二、谈谈你对keep-alive-的了解？" class="header-anchor">#</a> 十二、谈谈你对keep-alive 的了解？</h2> <p>keep-alive是vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染。</p> <ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li> <li>提供include和exclude属性，两者都支持字符串或正则表达式，include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存，其中exclude的优先级比includ高；</li> <li>对应两个钩子函数activated和deactivated，当组件被激活时，触发钩子函数activated，当组件被移除时，触发钩子函数deactivated。</li></ul> <h2 id="十三、组件中data为什么是一个函数？"><a href="#十三、组件中data为什么是一个函数？" class="header-anchor">#</a> 十三、组件中data为什么是一个函数？</h2> <p>为什么组件中的data必须是个函数，然后return一个对象，而new Vue实例，data可以是个对象？
因为组件是用来复用的，JS里的对象引用关系，如果组件中的data是一个对象，那么这样作用域没有隔离，子组件中的data属性值会互相影响，如果组件中的data是个函数，那么每个实例是独立的，组件实例之间互不影响。而new Vue实例是不会被复用的，因此不存在引用对象的问题。</p> <h2 id="十四、v-model-的原理？"><a href="#十四、v-model-的原理？" class="header-anchor">#</a> 十四、v-model 的原理？</h2> <p>原理：Object.defineProperty 中的get 和 set 方法</p> <p>getter和setter访问器
作用：指定读取或设置对象属性值的时候，执行的操作</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">dineProperty</span><span class="token punctuation">(</span>obj <span class="token punctuation">,</span> ‘msg’ <span class="token punctuation">,</span> <span class="token punctuation">{</span> 
    <span class="token function-variable function">set</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">get</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">newVal<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>例如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>input type<span class="token operator">=</span>“text”  id<span class="token operator">=</span>“text” <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>span id <span class="token operator">=</span>“sp”<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>

<span class="token keyword">var</span> txt <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>’txt’<span class="token punctuation">)</span><span class="token punctuation">,</span>
      sp <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span>'sp’<span class="token punctuation">)</span><span class="token punctuation">,</span>
      obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>


<span class="token comment">//给对象添加msg属性，并设置setter访问器</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> ’msg’<span class="token punctuation">,</span> <span class="token punctuation">{</span>
<span class="token comment">//设置obj.msg, 当obj.msg发生改变时set方法将会被调用</span>
    <span class="token function-variable function">set</span> <span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//当obj.msg 被赋值时 同时设置给input / span</span>
        txt<span class="token punctuation">.</span>value <span class="token operator">=</span> newVal
        sp<span class="token punctuation">.</span>innerText <span class="token operator">=</span> newVal
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">//监听文本框的改变，当文本输入内容时 改变obj.msg</span>
txt<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>‘keyup’<span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>msg <span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="十五、vue组件间的通信有哪几种方式？"><a href="#十五、vue组件间的通信有哪几种方式？" class="header-anchor">#</a> 十五、Vue组件间的通信有哪几种方式？</h2> <p>Vue组件间通信主要指3类通信：父子、隔代、兄弟。</p> <ol><li>props / $emit 适用父子</li> <li>ref / $parent / $children 适用父子</li> <li>EventBus （$emit / $on）适用于父子、隔代、兄弟</li> <li>$attrs / $listeners 适用于隔代</li> <li>provide / inject 适用于隔代</li> <li>Vuex 适用于父子、隔代、兄弟</li></ol> <h2 id="十六、vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#十六、vuex是什么？怎么使用？哪种功能场景使用它？" class="header-anchor">#</a> 十六、vuex是什么？怎么使用？哪种功能场景使用它？</h2> <p>vuex是一个专门为vue构建的状态集管理
主要是为了解决组件间状态共享问题，强调的是集中式管理
说白了就是便于维护，便于解耦，不是所有项目都适合使用vuex</p> <div class="custom-block danger"><p>vuex的核心：state、mutations、getters、actions、modules五大模块</p></div> <h2 id="十七、导航钩子有哪些？它们有哪些参数？"><a href="#十七、导航钩子有哪些？它们有哪些参数？" class="header-anchor">#</a> 十七、导航钩子有哪些？它们有哪些参数？</h2> <p>导航钩子翻译过来就是路由的生命周期（<code>vue-router</code>）
主要分为两种 全局和局部
全局的钩子函数
<code>beforeEach</code>：在路由开始切换时调用
用法：</p> <div class="language-js extra-class"><pre class="language-js"><code>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to，<span class="token keyword">from</span>，next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span class="token punctuation">)</span>
to <span class="token operator">:</span> 即将进入的目标对象
<span class="token keyword">from</span> <span class="token operator">:</span> 当前导航要离开的导航对象
next <span class="token operator">:</span> 是一个函数 调用resolve，执行下一步
afterEach：在路由切换离开时调用
局部到单个路由
beforeEnter
组件的钩子函数
beforeRouterEnter
beforeRouterUpdate
beforeRouterLeave
</code></pre></div><h2 id="十八、异步dom更新"><a href="#十八、异步dom更新" class="header-anchor">#</a> 十八、异步DOM更新</h2> <p>说明：vue异步执行DOM更新，监视所有数据改变，一次性更新DOM
优势：可以去除重复数据，对于避免不必要的计算和避免重复DOM操作上，非常重要
如果需要拿到更新后dom中的数据则需要通过 <code>Vue.$nextTick(callback)</code> : 在DOM更新后，执行某个操作</p> <div class="language-js extra-class"><pre class="language-js"><code>methods<span class="token operator">:</span><span class="token punctuation">{</span>
   <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> ‘change’
       <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="十九、vue-loader解释一下"><a href="#十九、vue-loader解释一下" class="header-anchor">#</a> 十九、vue-loader解释一下</h2> <p>vue-loader 就是一个加载器，能把.vue组件转化为js模块
为什么要转译这个vue组件？
可以动态渲染一些数据
对三个标签做了优化 script中可以直接使用es6  style  也默认可以使用sass，并且还提供了作用域的选择
还提供热加载</p> <h2 id="二十、用过插槽吗？用的是具名插槽还是匿名插槽？"><a href="#二十、用过插槽吗？用的是具名插槽还是匿名插槽？" class="header-anchor">#</a> 二十、用过插槽吗？用的是具名插槽还是匿名插槽？</h2> <p>slot插槽说白了就是个占位的东西
vue中插槽分为三种：默认插槽（匿名插槽）、 具名插槽和作用于插槽</p> <h2 id="二十一、说说你对虚拟dom-的理解"><a href="#二十一、说说你对虚拟dom-的理解" class="header-anchor">#</a> 二十一、说说你对虚拟DOM 的理解</h2> <p>什么是虚拟DOM？（真实的dom是dom树   虚拟dom是js对象）
说白了就是以js对象形式去添加dom元素 本质上优化了diff算法，采用了新旧dom对比，获取差异然后一次性更新到真实dom上</p> <h2 id="二十二、pre-和cloak-指令"><a href="#二十二、pre-和cloak-指令" class="header-anchor">#</a> 二十二、pre 和cloak 指令</h2> <p>提升性能：v-pre</p> <div class="custom-block danger"><p>说明：vue会跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译</p></div> <p>v-cloak 防止页面加载时出现 vue.js 的变量名</p> <div class="custom-block danger"><p>一般情况下面，要把这个放在页面下面加载防止页面加载慢，但是上面的{{message可能显示出来不好看，所有在上面的p标签加入v-cloak表示页面加载完成再显示 <code>[v-cloak] { display: none; }</code></p></div> <h2 id="二十三、什么是-mixin？"><a href="#二十三、什么是-mixin？" class="header-anchor">#</a> 二十三、什么是 mixin？</h2> <p>Mixins 使我们能够为 Vue 组件编写可插拔和可重用的功能。如果你希望在多个组件之间重用一组组件选项，例如生命周期 hook、方法等，则可以将其编写为 mixin，并在组件中简单地引用它。然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优先于组件自己的 hook</p> <h2 id="二十四、key的作用"><a href="#二十四、key的作用" class="header-anchor">#</a> 二十四、key的作用</h2> <p>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 key的作用主要是为了高效的更新虚拟DOM。</p> <h2 id="二十五、怎么定义-vue-router-的动态路由-怎么获取传过来的值？"><a href="#二十五、怎么定义-vue-router-的动态路由-怎么获取传过来的值？" class="header-anchor">#</a> 二十五、怎么定义 vue-router 的动态路由? 怎么获取传过来的值？</h2> <p>在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。</p> <h2 id="二十六、路由懒加载"><a href="#二十六、路由懒加载" class="header-anchor">#</a> 二十六、路由懒加载</h2> <p>使用了路由懒加载，打包会后的js文件是一个一个的。</p> <h2 id="二十七、为何vue中采用异步更新？"><a href="#二十七、为何vue中采用异步更新？" class="header-anchor">#</a> 二十七、为何Vue中采用异步更新？</h2> <p>首先我们要知道vue是组件级更新，如果不采用异步更新的话，每一次数据更新都会对当前组件重新渲染，所以为了性能考虑，Vue会在本轮数据更新后，再去更新异步视图。</p> <h2 id="二十八、vue中是如何检测数组变化？"><a href="#二十八、vue中是如何检测数组变化？" class="header-anchor">#</a> 二十八、Vue中是如何检测数组变化？</h2> <ol><li>改变数组的原型指向</li> <li>监测数组中每一项</li></ol> <h2 id="二十九、nexttick实现原理？"><a href="#二十九、nexttick实现原理？" class="header-anchor">#</a> 二十九、nextTick实现原理？</h2> <p>nextTick方法主要用的是宏任务和微任务，定义一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空队列，所以这个nextTick 就是异步方法</p> <h2 id="三十、vue中computed特点"><a href="#三十、vue中computed特点" class="header-anchor">#</a> 三十、Vue中computed特点</h2> <p>默认computed也是一个watcher具备缓存的，只要当依赖的属性发生变化时才会更新视图</p> <h2 id="三十一、解释一下编译过程"><a href="#三十一、解释一下编译过程" class="header-anchor">#</a> 三十一、解释一下编译过程</h2> <p>Vue会通过编译器将模板通过几个阶段最终编译为render函数，然后将render函数生成虚拟DOM最终映射成真是DOM
分为三个阶段</p> <ol><li>将模板解析为AST</li> <li>优化AST</li> <li>将AST转换为render函数</li></ol></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">更新时间: </span> <span class="time">2020年4月16日星期四下午3点29分</span></div></footer> <!----></main> <!----> <div style="display:none;" data-v-146b4d24 data-v-146b4d24><div class="comments-wrapper" data-v-146b4d24><!----></div></div></div></div></div></div><div class="global-ui"><!----><!----><!----><div id="goTop" class="hide-cat" data-v-3cd57a9e></div><canvas id="vuepress-canvas-ribbon"></canvas><canvas id="vuepress-canvas-cursor"></canvas></div></div>
    <script src="/assets/js/app.50e95c75.js" defer></script><script src="/assets/js/3.d50137cb.js" defer></script><script src="/assets/js/1.31fe4405.js" defer></script><script src="/assets/js/23.fa856cca.js" defer></script><script src="/assets/js/9.ca18e909.js" defer></script>
  </body>
</html>
